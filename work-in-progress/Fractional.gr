import Parallel

data Colour = Colour (Int, (Int, Int))

scarlet : *Colour -> *Colour
scarlet c =
    let x = c;
        y = x
    in y

scarlet' : *Colour -> !Colour
scarlet' c =
    let [s] = share c;
        [x] = [s];
        [y] = [s]
    in [x]

observe : forall {p : Permission, f : p} . & f Colour -> & f Colour
observe = ?

-- unification bug here
-- persimmon : *Colour -> *Colour
-- persimmon c =
--     withBorrow (\b ->
--         let (x, y) = split b;
--             x' = observe x;
--             b = join (x', y)
--         in b) c

mutate : & Whole Colour -> & Whole Colour
mutate = ?

viridian : *Colour -> *Colour
viridian c =
    withBorrow mutate c

transform : & Whole Int -> & Whole Int
transform = ?

indigo : *(Int, (Int, Int)) -> *(Int, (Int, Int))
indigo c = 
    let (r, p) = uniquePush c;
        r' = withBorrow transform r
        in uniquePull (r', p)

-- would be much neater if we could derive push and pull for Colour
indigo' : *(Int, (Int, Int)) -> *(Int, (Int, Int))
indigo' c = 
    let (r, p) = uniquePush c;
        (g, b) = uniquePush p;
        (r', b') = par (\() -> withBorrow transform r) (\() -> withBorrow transform b);
        p' = uniquePull (g, b')
        in uniquePull (r', p')

-- need arbitrary fractions for this one (but looks fine to me)
-- amethyst : *Colour -> *Colour
-- amethyst c =
--     withBorrow (\b ->
--         let (x, y) = split b;
--             (l, r) = split x;
--             x' = join (l, r);
--             b = join (x', y)
--         in b) c