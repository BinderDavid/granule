import Parallel

data Colour = Colour (Int, (Int, Int))

observe : forall {p : Permission, f : p} . & f Colour -> & f Colour
observe x = x -- placeholder for the sake of example

-- Currently broken due to unification
-- persimmon : *Colour -> *Colour
-- persimmon c =
--   withBorrow (\b -> let (x, y) = split b;
--                          x' = observe x;
--                          f = join (x', y) in f) c

mutate : & 1 Colour -> & 1 Colour
mutate x = x -- placeholder for the sake of example

viridian : *Colour -> *Colour
viridian c =
    withBorrow mutate c

transform : & 1 Int -> & 1 Int
transform x = x -- placeholder for the sake of example

indigo : *(Int, (Int, Int)) -> *(Int, (Int, Int))
indigo c = 
    let (r, p) = uniquePush c;
        r' = withBorrow transform r
        in uniquePull (r', p)

-- would be much neater if we could derive push and pull for Colour
indigo' : *(Int, (Int, Int)) -> *(Int, (Int, Int))
indigo' c = 
    let (r, p) = uniquePush c;
        (g, b) = uniquePush p;
        (r', b') = par (\() -> withBorrow transform r) (\() -> withBorrow transform b);
        p' = uniquePull (g, b') in uniquePull (r', p')

-- Currently broken due to unification
-- amethyst : *Colour -> *Colour
-- amethyst c =
--     withBorrow (\b -> let (x, y) = split b;
--                           (l, r) = split x;
--                           x' = join (l, r);
--                           f = join (x', y) in f) c

-- Currently allowed and should be rejected
bad : & 1/2 Colour -> & 2/1 Colour
bad x = x
